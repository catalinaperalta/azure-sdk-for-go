// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package duration

import (
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"time"
)

// parseISO8601 takes a slice of token strings that it will parse into a time.Duration.
func parseISO8601(matches []string) (time.Duration, error) {
	// check for positive or negative duration value
	sign := 1.0
	if len(matches[1]) > 0 && matches[1] == "-" {
		sign = -1.0
	}
	// if no years or months are sent, then go ahead and parse the values into the time.Duration
	if len(matches[2]) == 0 && len(matches[3]) == 0 {
		days := parseFloat64(matches[4]) * float64(24*time.Hour)
		hours := parseFloat64(matches[6]) * float64(time.Hour)
		minutes := parseFloat64(matches[7]) * float64(time.Minute)
		seconds := parseFloat64(matches[8]) * float64(time.Second)
		return time.Duration((days + hours + minutes + seconds) * sign), nil
	}
	// get the number of years, months and days specified for the duration
	years := parseInt64(matches[2])
	months := parseInt64(matches[3])
	days := parseInt64(matches[4])
	// get the current time in order to add the duration to it and then get the duration from there
	now := time.Now()
	// and the duration specified in the years, months and days
	t := now.AddDate(int(years), int(months), int(days))
	// get the duration for the time section of the standard
	hours := parseFloat64(matches[6]) * float64(time.Hour)
	minutes := parseFloat64(matches[7]) * float64(time.Minute)
	seconds := parseFloat64(matches[8]) * float64(time.Second)
	durSub := time.Duration(hours + minutes + seconds)
	// add the duration to the time we have been working with
	t = t.Add(durSub)
	// subtract the original time in order to get the value of the duration and multiple it by the sign
	// that was initially detected to get the result with the correct sign
	dur := t.Sub(now) * time.Duration(sign)
	return dur, nil
}

// parseDuration will check for a valid duration format and parse according to the identified format in order
// to return a valid time.Duration. If a valid format is not received it will fail.
func Parse(s string) (time.Duration, error) {
	// TODO Do we want to/have to support weeks?
	iso8601Format := regexp.MustCompile(`P([+-]?)?(\d+(?:\.\d+)?Y)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?D)?(T(\d+(?:\.\d+)?H)?(\d+(?:\.\d+)?M)?(\d+(?:\.\d+)?S)?)?`)
	if matches := iso8601Format.FindStringSubmatch(s); len(matches) > 0 {
		return parseISO8601(matches)
	}
	// TODO implement alternate duration parsing here, similar to:
	// https://github.com/gweis/isodate/blob/27cebc56a0f6a900eeb897512879d545095f410b/src/isodate/isoduration.py#L88
	return 0, errors.New("Could not find a valid duration format")
}

// toISO8601 parses a time.Duration into a string in the format of ISO 8601 duration.
// This function provides up to millisecond precision.
func ToISO8601(duration time.Duration) string {
	s := "P"
	days, remainder := duration.Milliseconds()/8.64e+7, duration.Milliseconds()%8.64e+7
	hours, remainder := remainder/3.6e+6, remainder%3.6e+6
	minutes, remainder := remainder/60000, remainder%60000
	seconds, remainder := remainder/1000, remainder%1000
	if days > 0 {
		s += fmt.Sprintf("%dD", days)
	}
	if hours > 0 || minutes > 0 || seconds > 0 {
		s += "T"
		if hours > 0 {
			s += fmt.Sprintf("%dH", hours)
		}
		if minutes > 0 {
			s += fmt.Sprintf("%dM", minutes)
		}
		if seconds > 0 {
			if remainder > 0 {
				// get remainder up to millisecond precision
				sec := float64(remainder) / 1000
				sec += float64(seconds)
				floatStr := strconv.FormatFloat(sec, 'f', -1, 64)
				s += fmt.Sprintf("%sS", floatStr)
			} else {
				s += fmt.Sprintf("%dS", seconds)
			}
		}
	}
	return s
}

func parseFloat64(value string) float64 {
	if len(value) == 0 {
		return 0
	}
	parsed, err := strconv.ParseFloat(value[:len(value)-1], 64)
	if err != nil {
		return 0
	}
	return parsed
}

func parseInt64(value string) int64 {
	if len(value) == 0 {
		return 0
	}
	parsed, err := strconv.ParseInt(value[:len(value)-1], 10, 64)
	if err != nil {
		return 0
	}
	return parsed
}
